import { type Node, type Solid, NodeType } from './types.ts';
import setup from './setup.ts';
export declare function unwrap_each<T>(arr: readonly T[] | null | undefined): ArrayIterator<T>;
export declare function append_array<T>(arr: T[], items: readonly T[]): void;
export declare function unwrap_append<T>(arr: T[], item: T | null | undefined): void;
export declare function unwrap_append_array<T>(arr: T[], items: readonly T[] | null | undefined): void;
export declare function owner_each_child(o: Solid.Owner): ArrayIterator<Solid.Owner>;
export declare let is_solid_proxy: (value: unknown) => value is {
    [setup.solid.$PROXY]: unknown;
};
export declare const isSolidOwner: (o: Solid.SourceMapValue | Solid.Owner | Solid.Store | Solid.Signal) => o is Solid.Owner;
export declare const isSolidComputation: (o: Solid.Owner) => o is Solid.Computation;
export declare const isSolidRoot: (o: Solid.Owner) => o is Solid.Root;
export declare const isSolidMemo: (o: Solid.Owner) => o is Solid.Memo;
export declare const isSolidComponent: (o: Solid.Owner) => o is Solid.Component;
export declare const isStoreNode: (o: object) => o is Solid.StoreNode;
export declare const isSolidStore: (o: Solid.Owner | Solid.SourceMapValue | Solid.Store) => o is Solid.Store;
export declare const isSolidSignal: (o: Solid.SourceMapValue) => o is Solid.Signal;
export declare function getNodeType(o: Solid.SourceMapValue | Solid.Signal | Solid.Owner | Solid.Store): NodeType;
export declare const getOwnerType: (o: Solid.Owner) => NodeType;
export declare function getNode(o: Solid.SourceMapValue | Solid.Signal | Solid.Owner | Solid.Store): Node;
export declare const getNodeName: (o: {
    component?: ((..._: any) => any) & {
        displayName?: string;
    };
    name?: string;
}) => string | undefined;
export declare function markOwnerType(o: Solid.Owner): NodeType;
/**
 * Checks if the passed owner is disposed.
 */
export declare function isDisposed(o: Readonly<Solid.Owner>): boolean;
export declare function onCleanup(fn: () => void): void;
export declare function getComponentRefreshNode(owner: Readonly<Solid.Component>): Solid.Memo | null;
export declare function resolveElements(value: unknown): HTMLElement[] | null;
/**
 * helper to getting to an owner that you want â€” walking downwards
 */
export declare function findOwner(root: Solid.Owner, predicate: (owner: Solid.Owner) => boolean): Solid.Owner | null;
export declare function lookupOwner(owner: Solid.Owner, predicate: (owner: Solid.Owner) => boolean): Solid.Owner | null;
/**
 * Attach onCleanup callback to a reactive owner
 * @param prepend add the callback to the front of the stack, instead of pushing, fot it to be called before other cleanup callbacks.
 * @returns a function to remove the cleanup callback
 */
export declare function onOwnerCleanup(owner: Solid.Owner, fn: VoidFunction, prepend?: boolean, symbol?: symbol): VoidFunction;
/**
 * Attach onCleanup callback to the parent of a reactive owner if it has one.
 * @param prepend add the callback to the front of the stack, instead of pushing, fot it to be called before other cleanup callbacks.
 * @returns a function to remove the cleanup callback
 */
export declare function onParentCleanup(owner: Solid.Owner, fn: VoidFunction, prepend?: boolean, symbol?: symbol): VoidFunction;
/**
 * Listen to when the owner is disposed. (not on cleanup)
 */
export declare function onOwnerDispose(owner: Solid.Owner, fn: VoidFunction, prepend?: boolean, symbol?: symbol): VoidFunction;
//# sourceMappingURL=utils.d.ts.map