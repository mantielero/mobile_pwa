var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/.pnpm/solid-js@1.9.7/node_modules/solid-js/dist/solid.js
var sharedConfig = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: false,
  getContextId() {
    return getContextId(this.context.count);
  },
  getNextContextId() {
    return getContextId(this.context.count++);
  }
};
function getContextId(count) {
  const num = String(count), len = num.length - 1;
  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: sharedConfig.getNextContextId(),
    count: 0
  };
}
var IS_DEV = false;
var equalFn = (a, b) => a === b;
var $PROXY = Symbol("solid-proxy");
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceConfig = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s)) value2 = value2(s.tValue);
      else value2 = value2(s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn, value, options) {
  const c = createComputation(fn, value, true, STALE);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createRenderEffect(fn, value, options) {
  const c = createComputation(fn, value, false, STALE);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
  if (s) c.suspense = s;
  if (!options || !options.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else updateComputation(c);
  return readSignal.bind(c);
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (!ExternalSourceConfig && Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
    return fn();
  } finally {
    Listener = listener;
  }
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getListener() {
  return Listener;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev;
    Listener = prevListener;
  }
}
function startTransition(fn) {
  if (Transition && Transition.running) {
    fn();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    runUpdates(fn, false);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
function useContext(context) {
  let value;
  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;
}
var SuspenseContext;
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (runningTransition ? this.tState : this.state)) {
    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this)) return this.tValue;
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    if (Transition) {
      const TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value;
      }
      if (!TransitionRunning) node.value = value;
    } else node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) continue;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
          else o.tState = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        Listener = Owner = node;
        runComputation(node, node.tValue, time);
        Listener = Owner = null;
      }, false);
    });
  }
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      if (Transition && Transition.running) {
        node.tState = STALE;
        node.tOwned && node.tOwned.forEach(cleanNode);
        node.tOwned = void 0;
      } else {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state;
  }
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned) Owner.tOwned = [c];
      else Owner.tOwned.push(c);
    } else {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  if (ExternalSourceConfig && c.fn) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
    c.fn = (x) => {
      track();
      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
    };
  }
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if ((runningTransition ? node.tState : node.state) === 0) return;
  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node)) return;
    if (runningTransition ? node.tState : node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (runningTransition) {
      let top = node, prev = ancestors[i + 1];
      while ((top = top.owner) && top !== prev) {
        if (Transition.disposed.has(top)) return;
      }
    }
    if ((runningTransition ? node.tState : node.state) === STALE) {
      updateComputation(node);
    } else if ((runningTransition ? node.tState : node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
    else runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  let res;
  if (Transition) {
    if (!Transition.promises.size && !Transition.queue.size) {
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      Effects.push.apply(Effects, Transition.effects);
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d of disposed) cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
          }
          if (v.tOwned) v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      }, false);
    } else if (Transition.running) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
  }
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
  if (res) res();
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const tasks = Transition.queue;
    if (!tasks.has(item)) {
      tasks.add(item);
      Scheduler(() => {
        tasks.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  if (sharedConfig.context) {
    if (sharedConfig.count) {
      sharedConfig.effects || (sharedConfig.effects = []);
      sharedConfig.effects.push(...queue.slice(0, userLength));
      return;
    }
    setHydrateContext();
  }
  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
    queue = [...sharedConfig.effects, ...queue];
    userLength += sharedConfig.effects.length;
    delete sharedConfig.effects;
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition) node.tState = 0;
  else node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state = runningTransition ? source.tState : source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (runningTransition ? !o.tState : !o.state) {
      if (runningTransition) o.tState = PENDING;
      else o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
    delete node.tOwned;
  }
  if (Transition && Transition.running && node.pure) {
    reset(node, true);
  } else if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  if (Transition && Transition.running) node.tState = 0;
  else node.state = 0;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
  }
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function runErrors(err, fns, owner) {
  try {
    for (const f of fns) f(err);
  } catch (e) {
    handleError(e, owner && owner.owner || null);
  }
}
function handleError(err, owner = Owner) {
  const fns = ERROR && owner && owner.context && owner.context[ERROR];
  const error2 = castError(err);
  if (!fns) throw error2;
  if (Effects) Effects.push({
    fn() {
      runErrors(error2, fns, owner);
    },
    state: STALE
  });
  else runErrors(error2, fns, owner);
}
var FALLBACK = Symbol("fallback");
var hydrationEnabled = false;
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r = untrack(() => Comp(props || {}));
      setHydrateContext(c);
      return r;
    }
  }
  return untrack(() => Comp(props || {}));
}
var narrowedError = (name) => `Stale read from <${name}>.`;
function Show(props) {
  const keyed = props.keyed;
  const conditionValue = createMemo(() => props.when, void 0, void 0);
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a, b) => !a === !b
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c : () => {
        if (!untrack(condition)) throw narrowedError("Show");
        return conditionValue();
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
var DEV = void 0;

// node_modules/.pnpm/solid-js@1.9.7/node_modules/solid-js/web/dist/web.js
var booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
var Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "noValidate", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
function reconcileArrays(parentNode, a, b) {
  let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
function template(html, isImportNode, isSVG, isMathML) {
  let node;
  const create = () => {
    const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    t.innerHTML = html;
    return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
  };
  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function className(node, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function isHydrating(node) {
  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  const hydrating = isHydrating(parent);
  if (hydrating) {
    !current && (current = [...parent.childNodes]);
    let cleaned = [];
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
      else cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (hydrating) return current;
    if (t === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (hydrating) return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (hydrating) {
      if (!array.length) return current;
      if (marker === void 0) return current = [...parent.childNodes];
      let node = array[0];
      if (node.parentNode !== parent) return current;
      const nodes = [node];
      while ((node = node.nextSibling) !== marker) nodes.push(node);
      return current = nodes;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (hydrating && value.parentNode) return current = multi ? [value] : value;
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
var RequestContext = Symbol();
var isServer = false;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
function Portal(props) {
  const {
    useShadow
  } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(() => {
    if (hydrating) getOwner().user = hydrating = false;
    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
    const el = mount();
    if (el instanceof HTMLHeadElement) {
      const [clean, setClean] = createSignal(false);
      const cleanup = () => setClean(true);
      createRoot((dispose) => insert(el, () => !clean() ? content() : dispose(), null));
      onCleanup(cleanup);
    } else {
      const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
        mode: "open"
      }) : container;
      Object.defineProperty(container, "_$host", {
        get() {
          return marker.parentNode;
        },
        configurable: true
      });
      insert(renderRoot, content);
      el.appendChild(container);
      props.ref && props.ref(container);
      onCleanup(() => el.removeChild(container));
    }
  }, void 0, {
    render: !hydrating
  });
  return marker;
}

// node_modules/.pnpm/@solid-primitives+utils@6.3.1_solid-js@1.9.7/node_modules/@solid-primitives/utils/dist/index.js
var isClient = !isServer;
var isDev = isClient && !!DEV;
var noop = () => void 0;
var trueFn = () => true;
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
function chain(callbacks) {
  return (...args) => {
    for (const callback of callbacks)
      callback && callback(...args);
  };
}
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
function defer(deps, fn, initialValue) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let shouldDefer = true;
  return (prevValue) => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++)
        input[i] = deps[i]();
    } else
      input = deps();
    if (shouldDefer) {
      shouldDefer = false;
      prevInput = input;
      return initialValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
var tryOnCleanup = isDev ? (fn) => getOwner() ? onCleanup(fn) : fn : onCleanup;
function createMicrotask(fn) {
  let calls = 0;
  let args;
  onCleanup(() => calls = 0);
  return (...a) => {
    args = a, calls++;
    queueMicrotask(() => --calls === 0 && fn(...args));
  };
}
function createHydratableSignal(serverValue, update, options) {
  if (isServer) {
    return createSignal(serverValue, options);
  }
  if (sharedConfig.context) {
    const [state, setState] = createSignal(serverValue, options);
    onMount(() => setState(() => update()));
    return [state, setState];
  }
  return createSignal(update(), options);
}

// node_modules/.pnpm/@solid-primitives+static-store@0.1.1_solid-js@1.9.7/node_modules/@solid-primitives/static-store/dist/index.js
function createStaticStore(init) {
  const copy = { ...init }, store = { ...init }, cache = {};
  const getValue = (key) => {
    let signal = cache[key];
    if (!signal) {
      if (!getListener())
        return copy[key];
      cache[key] = signal = createSignal(copy[key], { internal: true });
      delete copy[key];
    }
    return signal[0]();
  };
  for (const key in init) {
    Object.defineProperty(store, key, { get: () => getValue(key), enumerable: true });
  }
  const setValue = (key, value) => {
    const signal = cache[key];
    if (signal)
      return signal[1](value);
    if (key in copy)
      copy[key] = accessWith(value, copy[key]);
  };
  return [
    store,
    (a, b) => {
      if (isObject(a)) {
        const entries3 = untrack(() => Object.entries(accessWith(a, store)));
        batch(() => {
          for (const [key, value] of entries3)
            setValue(key, () => value);
        });
      } else
        setValue(a, b);
      return store;
    }
  ];
}

// packages/shared/dist/chunk-DTKGRNV6.js
function assert(condition, message, cause) {
  if (!condition) {
    throw Error(message ?? "Assertion failed", { cause });
  }
}
function msg(kind, data) {
  return { kind, data };
}
var LOG_LABEL_CYAN = `\x1B[1;30m\x1B[46msolid-devtools\x1B[0m`;
function warn(message, ...args) {
  console.warn(LOG_LABEL_CYAN + " " + message, ...args);
  return;
}
function trimString(str, maxLength) {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength) + "\u2026";
}
function mutate_remove(array, item) {
  const index = array.indexOf(item);
  if (index !== -1) array.splice(index, 1);
}

// node_modules/.pnpm/@solid-primitives+scheduled@1.5.1_solid-js@1.9.7/node_modules/@solid-primitives/scheduled/dist/index.js
var throttle = (callback, wait) => {
  if (isServer) {
    return Object.assign(() => void 0, { clear: () => void 0 });
  }
  let isThrottled = false, timeoutId, lastArgs;
  const throttled = (...args) => {
    lastArgs = args;
    if (isThrottled)
      return;
    isThrottled = true;
    timeoutId = setTimeout(() => {
      callback(...lastArgs);
      isThrottled = false;
    }, wait);
  };
  const clear = () => {
    clearTimeout(timeoutId);
    isThrottled = false;
  };
  if (getOwner())
    onCleanup(clear);
  return Object.assign(throttled, { clear });
};
var scheduleIdle = isServer ? () => Object.assign(() => void 0, { clear: () => void 0 }) : (
  // requestIdleCallback is not supported in Safari
  typeof requestIdleCallback !== "undefined" ? (callback, maxWait) => {
    let isDeferred = false, id, lastArgs;
    const deferred = (...args) => {
      lastArgs = args;
      if (isDeferred)
        return;
      isDeferred = true;
      id = requestIdleCallback(() => {
        callback(...lastArgs);
        isDeferred = false;
      }, { timeout: maxWait });
    };
    const clear = () => {
      cancelIdleCallback(id);
      isDeferred = false;
    };
    if (getOwner())
      onCleanup(clear);
    return Object.assign(deferred, { clear });
  } : (
    // fallback to setTimeout (throttle)
    // fallback to setTimeout (throttle)
    (callback) => throttle(callback)
  )
);

// packages/debugger/src/locator/locator.ts
var WINDOW_PROJECTPATH_PROPERTY = "$sdt_projectPath";
function getTargetURL(target, data) {
  if (typeof target === "function") return target(data);
  let { projectPath, file, line, column } = data;
  switch (target) {
    case "vscode":
      return `vscode://file/${projectPath}/${file}:${line}:${column}`;
    case "vscode-insiders":
      return `vscode-insiders://file/${projectPath}/${file}:${line}:${column}`;
    case "atom":
      return `atom://core/open/file?filename=${projectPath}/${file}&line=${line}&column=${column}`;
    case "webstorm":
      return `webstorm://open?file=${projectPath}/${file}&line=${line}&column=${column}`;
  }
}
var getProjectPath = () => window[WINDOW_PROJECTPATH_PROPERTY];
function getSourceCodeData(location) {
  let project_path = getProjectPath();
  if (project_path == null) return;
  return { ...location, projectPath: project_path };
}
function parseLocationString(location) {
  let [file, line, column] = location.split(":");
  if (file && line && column && typeof file === "string" && !isNaN(line = +line) && !isNaN(column = +column)) {
    return { file, line, column };
  }
}
function openSourceCode(target, data) {
  const url = getTargetURL(target, data);
  if (typeof url === "string") window.open(url, "_blank");
}

// packages/debugger/src/main/types.ts
var DEFAULT_MAIN_VIEW = "structure" /* Structure */;
var DEFAULT_WALKER_MODE = "components" /* Components */;
var UNKNOWN = "unknown";
var INSPECTED_STATE_NULL = {
  ownerId: null,
  signalId: null,
  treeWalkerOwnerId: null
};

// packages/debugger/src/main/id.ts
var WeakIdMap = /* @__PURE__ */ new WeakMap();
var RefMapMap = {
  ["OWNER" /* Owner */]: /* @__PURE__ */ new Map(),
  ["ELEMENT" /* Element */]: /* @__PURE__ */ new Map(),
  ["SIGNAL" /* Signal */]: /* @__PURE__ */ new Map(),
  ["STORE" /* Store */]: /* @__PURE__ */ new Map(),
  ["STORE_NODE" /* StoreNode */]: /* @__PURE__ */ new Map(),
  ["CUSTOM_VALUE" /* CustomValue */]: /* @__PURE__ */ new Map()
};
var CleanupRegistry = new FinalizationRegistry((data) => {
  RefMapMap[data.map].delete(data.id);
});
var LastId = 0;
var getNewSdtId = () => `#${(LastId++).toString(36)}`;
function getSdtId(obj, objType) {
  let id = WeakIdMap.get(obj);
  if (!id) {
    id = getNewSdtId();
    WeakIdMap.set(obj, id);
    RefMapMap[objType].set(id, new WeakRef(obj));
    CleanupRegistry.register(obj, { map: objType, id });
  }
  return id;
}
var get_id_el = (o) => getSdtId(o, "ELEMENT" /* Element */);
function getObjectById(id, objType) {
  const ref = RefMapMap[objType].get(id);
  return ref?.deref() ?? null;
}

// packages/debugger/src/main/setup.ts
if (!globalThis.SolidDevtools$$) {
  throw new Error(
    `[solid-devtools]: Debugger hasn't found the exposed Solid Devtools API. Did you import the setup script?`
  );
}
var setup = globalThis.SolidDevtools$$;
var setup_default = setup;

// packages/debugger/src/main/utils.ts
function* unwrap_each(arr) {
  if (arr != null) {
    yield* arr.values();
  }
}
function unwrap_append(arr, item) {
  if (item != null) {
    arr.push(item);
  }
}
function* owner_each_child(o) {
  yield* unwrap_each(o.owned);
  yield* unwrap_each(o.sdtSubRoots);
}
var is_solid_proxy = (value) => typeof value === "object" && value !== null && setup_default.solid.$PROXY in value;
var isSolidOwner = (o) => "owned" in o;
var isSolidComputation = (o) => !!o.fn;
var isSolidRoot = (o) => !("fn" in o);
var isSolidMemo = (o) => "fn" in o && "comparator" in o;
var isSolidComponent = (o) => "component" in o;
var isStoreNode = (o) => setup_default.store.$NODE in o;
var isSolidStore = (o) => !("observers" in o) && is_solid_proxy(o.value);
var isSolidSignal = (o) => "value" in o && "observers" in o && "observerSlots" in o && "comparator" in o;
function getNodeType(o) {
  if (isSolidOwner(o)) return getOwnerType(o);
  if (isSolidStore(o)) return "STORE" /* Store */;
  if (isSolidSignal(o)) return "SIGNAL" /* Signal */;
  else return "CUSTOM_VALUE" /* CustomValue */;
}
var SOLID_REFRESH_PREFIX = "[solid-refresh]";
var getOwnerType = (o) => {
  if (typeof o.sdtType !== "undefined") return o.sdtType;
  if (!isSolidComputation(o)) {
    if ("sources" in o) return "CATCH_ERROR" /* CatchError */;
    return "ROOT" /* Root */;
  }
  if (isSolidComponent(o)) return "COMPONENT" /* Component */;
  if ("comparator" in o) {
    if (
      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
      o.owner?.component?.name.startsWith(
        SOLID_REFRESH_PREFIX
      )
    ) {
      return "REFRESH" /* Refresh */;
    }
    return "MEMO" /* Memo */;
  }
  if (!o.pure) {
    if (o.user === true) return "EFFECT" /* Effect */;
    if (o.context !== null && (!o.owner || o.owner.context !== o.context))
      return "CONTEXT" /* Context */;
    return "RENDER" /* Render */;
  }
  return "COMPUTATION" /* Computation */;
};
function getNode(o) {
  return {
    kind: getNodeType(o),
    data: o
  };
}
var getNodeName = (o) => {
  let name;
  search: {
    if (typeof o.component === "function" && typeof o.component.displayName === "string" && o.component.displayName.length > 0) {
      name = o.component.displayName;
      break search;
    }
    if (o.name != null && o.name.length > 0) {
      name = o.name;
      break search;
    }
    return void 0;
  }
  if (name.startsWith(SOLID_REFRESH_PREFIX)) {
    name = name.slice(SOLID_REFRESH_PREFIX.length);
  }
  name = trimString(name, 36);
  return name;
};
function markOwnerType(o) {
  if (o.sdtType !== void 0) return o.sdtType;
  return o.sdtType = getOwnerType(o);
}
function isDisposed(o) {
  return !!(isSolidComputation(o) ? o.owner && (!o.owner.owned || !o.owner.owned.includes(o)) : o.isDisposed);
}
function getComponentRefreshNode(owner) {
  const { owned } = owner;
  let refresh;
  if (owned && owned.length === 1 && markOwnerType(refresh = owned[0]) === "REFRESH" /* Refresh */) {
    return refresh;
  }
  return null;
}
function lookupOwner(owner, predicate) {
  do {
    if (predicate(owner)) return owner;
    owner = owner.owner;
  } while (owner.owner);
  return null;
}
function onOwnerCleanup(owner, fn, prepend = false, symbol) {
  if (owner.cleanups === null) owner.cleanups = [fn];
  else {
    if (symbol) {
      if (owner.cleanups.some((c) => c[symbol])) {
        return () => owner.cleanups?.splice(
          owner.cleanups.findIndex((c) => c[symbol]),
          1
        );
      }
      ;
      fn[symbol] = true;
    }
    if (prepend) owner.cleanups.unshift(fn);
    else owner.cleanups.push(fn);
  }
  return () => owner.cleanups?.splice(owner.cleanups.indexOf(fn), 1);
}
function onParentCleanup(owner, fn, prepend = false, symbol) {
  if (owner.owner) return onOwnerCleanup(owner.owner, fn, prepend, symbol);
  return () => {
  };
}
function onOwnerDispose(owner, fn, prepend = false, symbol) {
  if (isSolidRoot(owner)) return onOwnerCleanup(owner, fn, prepend, symbol);
  return onParentCleanup(owner, fn, prepend, symbol);
}

// packages/debugger/src/main/observe.ts
var GraphUpdateListeners = /* @__PURE__ */ new Set();
setup_default.solid.hooks.afterUpdate = chain(GraphUpdateListeners);
function addSolidUpdateListener(onUpdate) {
  GraphUpdateListeners.add(onUpdate);
  return () => GraphUpdateListeners.delete(onUpdate);
}
function interceptComputationRerun(owner, onRun) {
  const _fn = owner.fn;
  let v;
  let prev;
  const fn = () => v = _fn(prev);
  owner.fn = !!owner.fn.length ? (p) => {
    onRun(fn, prev = p);
    return v;
  } : () => {
    onRun(fn, void 0);
    return v;
  };
}
var ComputationUpdateListeners = /* @__PURE__ */ new WeakMap();
function observeComputationUpdate(owner, onRun, symbol = Symbol()) {
  let map = ComputationUpdateListeners.get(owner);
  if (!map) ComputationUpdateListeners.set(owner, map = {});
  map[symbol] = onRun;
  interceptComputationRerun(owner, (fn) => {
    fn();
    for (const sym of Object.getOwnPropertySymbols(map)) map[sym]();
  });
}
function removeComputationUpdateObserver(owner, symbol) {
  const map = ComputationUpdateListeners.get(owner);
  if (map) delete map[symbol];
}
var SignalUpdateListeners = /* @__PURE__ */ new WeakMap();
function observeValueUpdate(node, onUpdate, symbol) {
  let map = SignalUpdateListeners.get(node);
  if (!map) {
    SignalUpdateListeners.set(node, map = /* @__PURE__ */ new Map());
    let value = node.value;
    Object.defineProperty(node, "value", {
      get: () => value,
      set: (newValue) => {
        for (const fn of map.values()) fn(newValue, value);
        value = newValue;
      }
    });
  }
  map.set(symbol, onUpdate);
}
function removeValueUpdateObserver(node, symbol) {
  SignalUpdateListeners.get(node)?.delete(symbol);
}
function makeValueUpdateListener(node, onUpdate, symbol) {
  observeValueUpdate(node, onUpdate, symbol);
  tryOnCleanup(() => removeValueUpdateObserver(node, symbol));
}

// packages/debugger/src/inspector/types.ts
var INFINITY = "Infinity";
var NEGATIVE_INFINITY = "NegativeInfinity";
var NAN = "NaN";
var UNDEFINED = "undefined";
var GLOBAL_GET_VALUE = "$SdtGetValue";

// packages/debugger/src/dependency/collect.ts
var $DGRAPH = Symbol("dependency-graph");
var Graph;
var VisitedSources;
var VisitedObservers;
var DepthMap;
var OnNodeUpdate;
function observeNodeUpdate(node, handler) {
  if (isSolidOwner(node)) observeComputationUpdate(node, handler, $DGRAPH);
  else observeValueUpdate(node, handler, $DGRAPH);
}
function unobserveNodeUpdate(node) {
  if (isSolidOwner(node)) removeComputationUpdateObserver(node, $DGRAPH);
  else removeValueUpdateObserver(node, $DGRAPH);
}
function addNodeToGraph(node) {
  const isOwner = isSolidOwner(node);
  const id = getSdtId(node, isOwner ? "OWNER" /* Owner */ : "SIGNAL" /* Signal */);
  if (Graph[id]) return;
  const onNodeUpdate = OnNodeUpdate;
  observeNodeUpdate(node, () => onNodeUpdate(id));
  Graph[id] = {
    name: getNodeName(node),
    type: getNodeType(node),
    depth: lookupDepth(node),
    sources: "sources" in node && node.sources ? node.sources.map(
      (n) => getSdtId(n, isSolidOwner(n) ? "OWNER" /* Owner */ : "SIGNAL" /* Signal */)
    ) : void 0,
    observers: "observers" in node && node.observers ? node.observers.map((n) => getSdtId(n, "OWNER" /* Owner */)) : void 0,
    graph: !isOwner && node.graph ? getSdtId(node.graph, "OWNER" /* Owner */) : void 0
  };
}
function visitSources(node) {
  let n = 0;
  if ("sources" in node && node.sources) {
    for (const source of node.sources) {
      const isOwner = isSolidOwner(source);
      if (isOwner && getOwnerType(source) === "REFRESH" /* Refresh */) continue;
      n++;
      if (VisitedSources.has(source)) continue;
      VisitedSources.add(source);
      if (isOwner && visitSources(source) === 0) {
        n--;
        continue;
      }
      addNodeToGraph(source);
    }
  }
  return n;
}
function visitObservers(node) {
  if ("observers" in node && node.observers) {
    for (const observer of node.observers) {
      if (VisitedObservers.has(observer) || getOwnerType(observer) === "REFRESH" /* Refresh */) {
        continue;
      }
      VisitedObservers.add(observer);
      addNodeToGraph(observer);
      visitObservers(observer);
    }
  }
}
function lookupDepth(node) {
  const id = getSdtId(node, isSolidOwner(node) ? "OWNER" /* Owner */ : "SIGNAL" /* Signal */);
  if (id in DepthMap) return DepthMap[id];
  let owner;
  if (!("owned" in node)) owner = node.graph;
  else if (!("fn" in node) && !node.owner) return 0;
  else owner = node.owner;
  return DepthMap[id] = owner ? lookupDepth(owner) + 1 : 0;
}
function collectDependencyGraph(node, config) {
  const graph = Graph = {};
  const visitedSources = VisitedSources = /* @__PURE__ */ new Set();
  const visitedObservers = VisitedObservers = /* @__PURE__ */ new Set();
  DepthMap = {};
  OnNodeUpdate = config.onNodeUpdate;
  addNodeToGraph(node);
  visitSources(node);
  visitObservers(node);
  const clearListeners = () => {
    visitedSources.forEach(unobserveNodeUpdate);
    visitedObservers.forEach(unobserveNodeUpdate);
    unobserveNodeUpdate(node);
  };
  Graph = VisitedObservers = VisitedSources = DepthMap = OnNodeUpdate = void 0;
  return { graph, clearListeners };
}

// packages/debugger/src/dependency/index.ts
function createDependencyGraph(props) {
  let clearListeners = null;
  const onNodeUpdate = (id) => {
    queueMicrotask(() => {
      if (!props.enabled()) return;
      props.onNodeUpdate(id);
      triggerInspect();
    });
  };
  const inspectedNode = createMemo(() => {
    const state = props.inspectedState();
    let node_raw = null;
    if (state.signalId) {
      node_raw = getObjectById(state.signalId, "SIGNAL" /* Signal */);
    } else if (state.ownerId) {
      node_raw = getObjectById(state.ownerId, "OWNER" /* Owner */);
    }
    if (node_raw != null) {
      return getNode(node_raw);
    }
    return null;
  });
  function inspectDGraph() {
    clearListeners?.();
    let node = inspectedNode();
    if (!props.enabled() || !node || node.kind === "ROOT" /* Root */ || node.kind === "COMPONENT" /* Component */ || node.kind === "CONTEXT" /* Context */) {
      clearListeners = null;
      props.emit(msg("DgraphUpdate", null));
      return;
    }
    const dgraph = collectDependencyGraph(node.data, {
      onNodeUpdate
    });
    clearListeners = dgraph.clearListeners;
    props.emit(msg("DgraphUpdate", dgraph.graph));
  }
  const triggerInspect = throttle(inspectDGraph, 200);
  createEffect(
    defer([props.enabled, inspectedNode], () => {
      queueMicrotask(inspectDGraph);
    })
  );
  return {
    onViewChange(_) {
      inspectDGraph();
    }
  };
}

// packages/debugger/src/main/roots.ts
var UNOWNED_ROOT = {
  cleanups: null,
  owned: null,
  context: null,
  owner: null,
  name: "UNOWNED",
  sdtType: "ROOT" /* Root */
};
var RootMap = /* @__PURE__ */ new Map();
var getCurrentRoots = () => RootMap.values();
var OnOwnerNeedsUpdate;
function setOnOwnerNeedsUpdate(fn) {
  OnOwnerNeedsUpdate = fn;
}
var OnRootRemoved;
function setOnRootRemoved(fn) {
  OnRootRemoved = fn;
}
function createTopRoot(owner) {
  const rootId = getSdtId(owner, "OWNER" /* Owner */);
  RootMap.set(rootId, owner);
  OnOwnerNeedsUpdate?.(owner, rootId);
}
function cleanupRoot(root) {
  const rootId = getSdtId(root, "OWNER" /* Owner */);
  root.isDisposed = true;
  changeRootAttachment(root, null);
  const wasTarcked = RootMap.delete(rootId);
  if (wasTarcked) OnRootRemoved?.(rootId);
}
function changeRootAttachment(root, newParent) {
  let topRoot;
  if (root.attachedTo) {
    root.attachedTo.sdtSubRoots.splice(root.attachedTo.sdtSubRoots.indexOf(root), 1);
    topRoot = getTopRoot(root.attachedTo);
    if (topRoot) OnOwnerNeedsUpdate?.(root.attachedTo, getSdtId(topRoot, "OWNER" /* Owner */));
  }
  if (newParent) {
    root.attachedTo = newParent;
    if (newParent.sdtSubRoots) newParent.sdtSubRoots.push(root);
    else newParent.sdtSubRoots = [root];
    if (topRoot === void 0) topRoot = getTopRoot(newParent);
    if (topRoot) OnOwnerNeedsUpdate?.(newParent, getSdtId(topRoot, "OWNER" /* Owner */));
  } else {
    delete root.attachedTo;
  }
}
function attachDebugger(owner = setup_default.solid.getOwner()) {
  if (!owner)
    return warn("reatachOwner helper should be called synchronously in a reactive owner.");
  const roots = [];
  let isFirstTopLevel = true;
  while (owner) {
    if (isSolidRoot(owner)) {
      if (owner.isDisposed) return;
      if (RootMap.has(getSdtId(owner, "OWNER" /* Owner */))) {
        isFirstTopLevel = false;
        break;
      }
      roots.push(owner);
    }
    owner = owner.owner;
  }
  for (let i = roots.length - 1; i >= 0; i--) {
    const root = roots[i];
    root.sdtType = "ROOT" /* Root */;
    onOwnerCleanup(root, () => cleanupRoot(root), true);
    const isTopLevel = isFirstTopLevel && i === 0;
    if (isTopLevel) {
      createTopRoot(root);
      return;
    }
    let parent = findClosestAliveParent(root);
    if (!parent.owner) return warn("Parent owner is missing.");
    changeRootAttachment(root, parent.owner);
    const onParentCleanup2 = () => {
      const newParent = findClosestAliveParent(root);
      changeRootAttachment(root, newParent.owner);
      if (newParent.owner) {
        parent = newParent;
        onOwnerCleanup(parent.root, onParentCleanup2);
      } else {
        removeOwnCleanup();
        createTopRoot(root);
      }
    };
    const removeParentCleanup = onOwnerCleanup(parent.root, onParentCleanup2);
    const removeOwnCleanup = onOwnerCleanup(root, removeParentCleanup);
  }
}
function getTopRoot(owner) {
  let root = null;
  do {
    if (isSolidRoot(owner) && !owner.isDisposed) root = owner;
    owner = owner.owner;
  } while (owner);
  return root;
}
function findClosestAliveParent(owner) {
  let disposed = null;
  let closestAliveRoot = null;
  let current = owner;
  while (current.owner && !closestAliveRoot) {
    current = current.owner;
    if (isSolidRoot(current)) {
      if (current.isDisposed) disposed = current;
      else closestAliveRoot = current;
    }
  }
  if (!closestAliveRoot) return { owner: null, root: null };
  return { owner: (disposed ?? owner).owner, root: closestAliveRoot };
}

// node_modules/.pnpm/@nothing-but+utils@0.17.0/node_modules/@nothing-but/utils/dist/misc.js
var misc_exports = {};
__export(misc_exports, {
  chain: () => chain2,
  entries: () => entries,
  false_fn: () => false_fn,
  is_non_nullable: () => is_non_nullable,
  is_of_class: () => is_of_class,
  is_plain_object: () => is_plain_object,
  keys: () => keys,
  noop: () => noop2,
  reverse_chain: () => reverse_chain,
  toError: () => toError,
  true_fn: () => true_fn,
  xor: () => xor
});
var noop2 = () => void 0;
var true_fn = () => true;
var false_fn = () => false;
function xor(a, b) {
  return a ? !b : b;
}
var entries = Object.entries;
var keys = Object.keys;
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
var is_plain_object = (value) => value && Object.getPrototypeOf(value) === Object.prototype;
var is_of_class = (v, c) => v instanceof c || v && v.constructor === c;
var is_non_nullable = (i) => i != null;
function chain2(callbacks) {
  return (...args) => {
    for (const callback of callbacks)
      callback && void callback(...args);
  };
}
function reverse_chain(callbacks) {
  return (...args) => {
    for (let i = callbacks.length - 1; i >= 0; i--) {
      const callback = callbacks[i];
      callback && void callback(...args);
    }
  };
}

// node_modules/.pnpm/@solid-primitives+event-listener@2.4.1_solid-js@1.9.7/node_modules/@solid-primitives/event-listener/dist/eventListener.js
function makeEventListener(target, type, handler, options) {
  target.addEventListener(type, handler, options);
  return tryOnCleanup(target.removeEventListener.bind(target, type, handler, options));
}

// node_modules/.pnpm/@solid-primitives+rootless@1.5.1_solid-js@1.9.7/node_modules/@solid-primitives/rootless/dist/index.js
function createSingletonRoot(factory, detachedOwner = getOwner()) {
  let listeners = 0, value, disposeRoot;
  return () => {
    listeners++;
    onCleanup(() => {
      listeners--;
      queueMicrotask(() => {
        if (!listeners && disposeRoot) {
          disposeRoot();
          disposeRoot = value = void 0;
        }
      });
    });
    if (!disposeRoot) {
      createRoot((dispose) => value = factory(disposeRoot = dispose), detachedOwner);
    }
    return value;
  };
}
function createHydratableSingletonRoot(factory) {
  const owner = getOwner();
  const singleton = createSingletonRoot(factory, owner);
  return () => isServer || sharedConfig.context ? createRoot(factory, owner) : singleton();
}
function createRootPool(factory, options = {}) {
  if (isServer) {
    const owner2 = getOwner();
    return (args) => createRoot((dispose) => factory(() => args, trueFn, dispose), owner2);
  }
  let length = 0;
  const { limit = 100 } = options, pool = new Array(limit), owner = getOwner(), mapRoot = factory.length > 1 ? (dispose, [args, set]) => {
    const [active, setA] = createSignal(true);
    const root = {
      dispose,
      set,
      setA,
      active,
      v: factory(args, active, () => disposeRoot(root))
    };
    return root;
  } : (dispose, [args, set]) => ({
    dispose,
    set,
    setA: trueFn,
    active: trueFn,
    v: factory(args, trueFn, noop)
  }), limitPool = createMicrotask(() => {
    if (length > limit) {
      for (let i = limit; i < length; i++) {
        pool[i].dispose();
        pool[i] = void 0;
      }
      length = limit;
    }
  }), cleanupRoot2 = (root) => {
    if (root.dispose !== noop) {
      pool[length++] = root;
      root.setA(false);
      limitPool();
    }
  }, disposeRoot = (root) => {
    root.dispose();
    root.dispose = noop;
    if (root.active())
      root.setA(false);
    else {
      pool[pool.indexOf(root)] = pool[--length];
      pool[length] = void 0;
    }
  };
  onCleanup(() => {
    for (let i = 0; i < length; i++)
      pool[i].dispose();
    length = 0;
  });
  return (arg) => {
    let root;
    if (length) {
      root = pool[--length];
      pool[length] = void 0;
      batch(() => {
        root.set(() => arg);
        root.setA(true);
      });
    } else
      root = createRoot((dispose) => mapRoot(dispose, createSignal(arg)), owner);
    onCleanup(() => cleanupRoot2(root));
    return root.v;
  };
}

// node_modules/.pnpm/@solid-primitives+keyboard@1.3.1_solid-js@1.9.7/node_modules/@solid-primitives/keyboard/dist/index.js
var useKeyDownEvent = /* @__PURE__ */ createSingletonRoot(() => {
  if (isServer) {
    return () => null;
  }
  const [event, setEvent] = createSignal(null);
  makeEventListener(window, "keydown", (e) => {
    setEvent(e);
    setTimeout(() => setEvent(null));
  });
  return event;
});
var useKeyDownList = /* @__PURE__ */ createSingletonRoot(() => {
  if (isServer) {
    const keys2 = () => [];
    keys2[0] = keys2;
    keys2[1] = { event: () => null };
    keys2[Symbol.iterator] = function* () {
      yield keys2[0];
      yield keys2[1];
    };
    return keys2;
  }
  const [pressedKeys, setPressedKeys] = createSignal([]), reset2 = () => setPressedKeys([]), event = useKeyDownEvent();
  makeEventListener(window, "keydown", (e) => {
    if (e.repeat || typeof e.key !== "string")
      return;
    const key = e.key.toUpperCase(), currentKeys = pressedKeys();
    if (currentKeys.includes(key))
      return;
    const keys2 = [...currentKeys, key];
    if (currentKeys.length === 0 && key !== "ALT" && key !== "CONTROL" && key !== "META" && key !== "SHIFT") {
      if (e.shiftKey)
        keys2.unshift("SHIFT");
      if (e.altKey)
        keys2.unshift("ALT");
      if (e.ctrlKey)
        keys2.unshift("CONTROL");
      if (e.metaKey)
        keys2.unshift("META");
    }
    setPressedKeys(keys2);
  });
  makeEventListener(window, "keyup", (e) => {
    if (typeof e.key !== "string")
      return;
    const key = e.key.toUpperCase();
    setPressedKeys((prev) => prev.filter((_key) => _key !== key));
  });
  makeEventListener(window, "blur", reset2);
  makeEventListener(window, "contextmenu", (e) => {
    e.defaultPrevented || reset2();
  });
  pressedKeys[0] = pressedKeys;
  pressedKeys[1] = { event };
  pressedKeys[Symbol.iterator] = function* () {
    yield pressedKeys[0];
    yield pressedKeys[1];
  };
  return pressedKeys;
});
var useCurrentlyHeldKey = /* @__PURE__ */ createSingletonRoot(() => {
  if (isServer) {
    return () => null;
  }
  const keys2 = useKeyDownList();
  let prevKeys = untrack(keys2);
  return createMemo(() => {
    const _keys = keys2();
    const prev = prevKeys;
    prevKeys = _keys;
    if (prev.length === 0 && _keys.length === 1)
      return _keys[0];
    return null;
  });
});
function createKeyHold(key, options = {}) {
  if (isServer) {
    return () => false;
  }
  key = key.toUpperCase();
  const { preventDefault = true } = options, event = useKeyDownEvent(), heldKey = useCurrentlyHeldKey();
  return createMemo(() => heldKey() === key && (preventDefault && event()?.preventDefault(), true));
}

// node_modules/.pnpm/@solid-primitives+media@2.3.1_solid-js@1.9.7/node_modules/@solid-primitives/media/dist/index.js
function createMediaQuery(query, serverFallback = false) {
  if (isServer) {
    return () => serverFallback;
  }
  const mql = window.matchMedia(query);
  const [state, setState] = createHydratableSignal(serverFallback, () => mql.matches);
  const update = () => setState(mql.matches);
  makeEventListener(mql, "change", update);
  return state;
}
function createPrefersDark(serverFallback) {
  return createMediaQuery("(prefers-color-scheme: dark)", serverFallback);
}
var usePrefersDark = /* @__PURE__ */ createHydratableSingletonRoot(createPrefersDark.bind(void 0, false));

// packages/shared/dist/primitives.js
var untrackedCallback = (fn) => (...a) => untrack(fn.bind(void 0, ...a));
var useIsTouch = createSingletonRoot(() => createMediaQuery("(hover: none)"));
var useIsMobile = createSingletonRoot(() => createMediaQuery("(max-width: 640px)"));

// packages/debugger/src/structure/walker.ts
var makeComponentRegistry = (eli) => {
  return {
    eli,
    components: /* @__PURE__ */ new Map(),
    element_nodes: /* @__PURE__ */ new Map()
  };
};
var clearComponentRegistry = (r) => {
  for (let component of r.components.values()) component.cleanup();
  r.components.clear();
  r.element_nodes.clear();
};
var cleanupComponent = (r, nodeID) => {
  let component = r.components.get(nodeID);
  if (component != null) {
    component.cleanup();
    r.components.delete(nodeID);
    for (let element of component.element_nodes) {
      r.element_nodes.delete(element);
    }
  }
};
var $CLEANUP = Symbol("component-registry-cleanup");
var registerComponent = (r, owner, id, name, elements) => {
  if (elements == null) {
    cleanupComponent(r, id);
    return;
  }
  let set = new Set(elements);
  let existing = r.components.get(id);
  if (existing != null) {
    existing.elements = set;
    return;
  }
  let cleanup = onOwnerCleanup(owner, () => cleanupComponent(r, id), false, $CLEANUP);
  r.components.set(id, {
    id,
    owner,
    name,
    elements: set,
    element_nodes: /* @__PURE__ */ new Set(),
    cleanup
  });
};
var registerElement = (r, component_id, element_id, element) => {
  if (component_id == null) {
    return;
  }
  let component = r.components.get(component_id);
  if (component == null) return;
  component.element_nodes.add(element_id);
  r.element_nodes.set(element_id, { el: element, component });
};
var getComponent = (r, id) => {
  let component = r.components.get(id);
  if (component != null) return {
    name: component.name,
    elements: [...component.elements],
    id
  };
  let el_data = r.element_nodes.get(id);
  if (el_data == null) return null;
  return {
    name: el_data.component.name,
    id: el_data.component.id,
    elements: [el_data.el]
  };
};
var findComponent = (r, el) => {
  let including = /* @__PURE__ */ new Map();
  for (let curr = el; curr != null && including.size === 0; ) {
    for (let comp of r.components.values()) {
      for (let comp_el of comp.elements) {
        if (comp_el === curr) {
          including.set(comp.owner, comp);
        }
      }
    }
    curr = r.eli.getParent(curr);
  }
  if (including.size > 1) {
    for (let owner of including.keys()) {
      if (including.has(owner)) {
        for (let curr = owner.owner; curr != null; ) {
          if (including.delete(curr)) break;
          curr = curr.owner;
        }
      }
    }
  }
  return including.values().next().value ?? null;
};
var $WALKER = Symbol("tree-walker");
function observeComputation(comp, owner_to_update, config) {
  let was_leaf = !comp.owned || comp.owned.length === 0;
  let { rootId, onUpdate: onComputationUpdate, mode } = config;
  let handler = () => {
    let is_leaf = !comp.owned || comp.owned.length === 0;
    let changed_structure = was_leaf !== is_leaf || !is_leaf || mode === "dom" /* DOM */;
    was_leaf = is_leaf;
    onComputationUpdate(rootId, owner_to_update, changed_structure);
  };
  observeComputationUpdate(comp, handler, $WALKER);
}
function resolveElements(value, eli, list = []) {
  pushResolvedElements(list, value, eli);
  return list;
}
function pushResolvedElements(list, value, eli) {
  if (value != null) {
    switch (typeof value) {
      case "function":
        if (value.length === 0 && value.name === "bound readSignal") {
          pushResolvedElements(list, value(), eli);
        }
        break;
      case "object":
        if (Array.isArray(value)) {
          for (let item of value) {
            pushResolvedElements(list, item, eli);
          }
        } else if (eli.isElement(value)) {
          list.push(value);
        }
        break;
    }
  }
}
function mapChildren(owner, component_id, config, children = []) {
  for (let child of owner_each_child(owner)) {
    if (config.mode === "owners" /* Owners */ || markOwnerType(child) === "COMPONENT" /* Component */) {
      unwrap_append(children, mapOwner(child, component_id, config));
    } else {
      if (isSolidComputation(child)) {
        observeComputation(child, owner, config);
      }
      mapChildren(child, component_id, config, children);
    }
  }
  return children;
}
var els_seen = /* @__PURE__ */ new Set();
function add_new_el_json(child_arr, el, comp_id, config) {
  let el_json = {
    id: get_id_el(el),
    type: "ELEMENT" /* Element */,
    name: config.eli.getName(el) ?? UNKNOWN,
    children: []
  };
  child_arr.push(el_json);
  els_seen.add(el);
  registerElement(config.registry, comp_id, el_json.id, el);
  return el_json;
}
function mapOwner(owner, last_comp_id, config) {
  let id = getSdtId(owner, "OWNER" /* Owner */);
  let type = markOwnerType(owner);
  let name = getNodeName(owner);
  let mapped = { id, type, name, children: [] };
  let resolved_els;
  if (type === "COMPONENT" /* Component */) {
    let first_owned;
    if (name === "provider" && owner.owned != null && owner.owned.length === 1 && markOwnerType(first_owned = owner.owned[0]) === "CONTEXT" /* Context */) {
      return mapOwner(first_owned, last_comp_id, config);
    }
    resolved_els = resolveElements(owner.value, config.eli);
    registerComponent(config.registry, owner, id, name, resolved_els);
    let refresh = getComponentRefreshNode(owner);
    if (refresh != null) {
      mapped.hmr = true;
      owner = refresh;
    }
    last_comp_id = id;
  } else if (isSolidComputation(owner)) {
    observeComputation(owner, owner, config);
    if (type != "CONTEXT" /* Context */ && (!owner.sources || owner.sources.length === 0)) {
      mapped.frozen = true;
    }
  }
  mapChildren(owner, last_comp_id, config, mapped.children);
  if (config.mode === "dom" /* DOM */) {
    resolved_els ??= resolveElements(owner.value, config.eli);
    let stack_els_arr = [resolved_els];
    let stack_els_idx = [0];
    let stack_els_own = [mapped];
    let stack_els_len = 1;
    let stack_child_arr = [mapped.children];
    let stack_child_idx = [0];
    let stack_child_len = 1;
    while (stack_child_len > 0) {
      let child_arr = stack_child_arr[stack_child_len - 1];
      let child_idx = stack_child_idx[stack_child_len - 1];
      if (child_idx >= child_arr.length) {
        stack_child_len -= 1;
        continue;
      }
      stack_child_idx[stack_child_len - 1] += 1;
      let child = child_arr[child_idx];
      if (child.type !== "ELEMENT" /* Element */) {
        stack_child_arr[stack_child_len] = child.children;
        stack_child_idx[stack_child_len] = 0;
        stack_child_len += 1;
        continue;
      }
      if (stack_child_len === 1)
        continue;
      while (stack_els_len > 0) {
        let el_arr = stack_els_arr[stack_els_len - 1];
        let el_idx = stack_els_idx[stack_els_len - 1];
        let el_own = stack_els_own[stack_els_len - 1];
        if (el_idx >= el_arr.length) {
          stack_els_len -= 1;
          continue;
        }
        stack_els_idx[stack_els_len - 1] += 1;
        let el = el_arr[el_idx];
        if (get_id_el(el) === child.id) {
          el_own.children.push(...mapped.children.splice(0, stack_child_idx[0]));
          stack_child_idx[0] = 0;
          stack_child_len = 1;
          for (let ci = child_idx + 1; ci < child_arr.length; ci++) {
            let ei = stack_els_idx[stack_els_len - 1];
            if (ei >= el_arr.length || child_arr[ci].id !== get_id_el(el_arr[ei]))
              break;
            stack_els_idx[stack_els_len - 1] += 1;
          }
          break;
        }
        if (!els_seen.has(el)) {
          stack_els_arr[stack_els_len] = config.eli.getChildren(el);
          stack_els_idx[stack_els_len] = 0;
          stack_els_own[stack_els_len] = add_new_el_json(el_own.children, el, last_comp_id, config);
          stack_els_len += 1;
        }
      }
    }
    while (stack_els_len > 0) {
      let el_arr = stack_els_arr[stack_els_len - 1];
      let el_idx = stack_els_idx[stack_els_len - 1];
      let el_own = stack_els_own[stack_els_len - 1];
      if (el_idx >= el_arr.length) {
        stack_els_len -= 1;
        continue;
      }
      stack_els_idx[stack_els_len - 1] += 1;
      let el = el_arr[el_idx];
      if (!els_seen.has(el)) {
        stack_els_arr[stack_els_len] = config.eli.getChildren(el);
        stack_els_idx[stack_els_len] = 0;
        stack_els_own[stack_els_len] = add_new_el_json(el_own.children, el, last_comp_id, config);
        stack_els_len += 1;
      }
    }
  }
  return mapped;
}
var walkSolidTree = /* @__PURE__ */ untrackedCallback(function(owner, config) {
  let r = mapOwner(owner, null, config);
  els_seen.clear();
  return r;
});

// packages/debugger/src/locator/element-overlay.tsx
var _tmpl$ = /* @__PURE__ */ template(`<style>`);
var _tmpl$2 = /* @__PURE__ */ template(`<div><div class=name-animated-container><div class=name-background></div><div class=name-text>: <span></span></div><div class=name-invisible>: `);
var _tmpl$3 = /* @__PURE__ */ template(`<div class=element-overlay><div class=border>`);
var _tmpl$4 = /* @__PURE__ */ template(`<div data-darkreader-ignore>`);
function createElementsOverlay(selected, eli) {
  const useElementOverlay = createRootPool((componentRaw, active) => {
    const component = () => active() ? componentRaw() : null;
    const name = () => component()?.name;
    const rect = createMemo((prev) => {
      let comp = component();
      if (comp === null) return prev;
      let rect2 = eli.getRect(comp.element);
      if (rect2 === null) return prev;
      return rect2;
    }, {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    const transform = () => `translate(${Math.round(rect().x)}px, ${Math.round(rect().y)}px)`;
    const placeOnTop = () => rect().y > window.innerHeight / 2;
    const tag = () => {
      let comp = component();
      if (comp === null) return UNKNOWN;
      return eli.getName(comp.element) ?? UNKNOWN;
    };
    return [(() => {
      var _el$ = _tmpl$();
      insert(_el$, styles);
      return _el$;
    })(), (() => {
      var _el$2 = _tmpl$3(), _el$3 = _el$2.firstChild;
      insert(_el$2, createComponent(Show, {
        get when() {
          return name();
        },
        get children() {
          var _el$4 = _tmpl$2(), _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$0 = _el$7.nextSibling, _el$1 = _el$0.firstChild;
          insert(_el$7, name, _el$8);
          insert(_el$9, tag);
          insert(_el$0, name, _el$1);
          insert(_el$0, tag, null);
          createRenderEffect(() => className(_el$4, `name-container ${placeOnTop() ? "top" : "bottom"}`));
          return _el$4;
        }
      }), null);
      createRenderEffect((_p$) => {
        var _v$ = transform(), _v$2 = rect().width + "px", _v$3 = rect().height + "px";
        _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$2.style.setProperty("transform", _v$) : _el$2.style.removeProperty("transform"));
        _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$2.style.setProperty("width", _v$2) : _el$2.style.removeProperty("width"));
        _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$2.style.setProperty("height", _v$3) : _el$2.style.removeProperty("height"));
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0
      });
      return _el$2;
    })()];
  });
  const owner = getOwner();
  setTimeout(() => {
    runWithOwner(owner, () => createComponent(Portal, {
      useShadow: true,
      get mount() {
        return document.documentElement;
      },
      get children() {
        var _el$10 = _tmpl$4();
        insert(_el$10, () => selected().map(useElementOverlay));
        return _el$10;
      }
    }));
  }, 1e3);
}
var styles = (
  /*css*/
  `
.element-overlay {
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  pointer-events: none;
  transition-duration: 100ms;
  transition-property: transform, width, height;
  --color: 14 116 144;
}
.border {
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border: 2px solid rgb(var(--color) / 0.8);
  background-color: rgb(var(--color) / 0.3);
  border-radius: 0.25rem;
}
.name-container {
  position: absolute;
  z-index: 10000;
  left: 0;
  right: 0;
  display: flex;
  justify-content: center;
  color: white;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
  font-size: 0.875rem;
  line-height: 1rem;
}
.name-container.bottom {
  top: 100%;
}
.name-container.top {
  bottom: 100%;
}
.name-animated-container {
  position: relative;
  margin: 0.5rem auto;
  padding: 0.25rem 0.5rem;
}
.name-background {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgb(var(--color) / 0.8);
  border-radius: 0.25rem;
}
.name-text {
  position: absolute;
}
.name-text span {
  color: #a5f3fc;
}
.name-invisible {
  visibility: hidden;
  width: max-content;
}
`
);

// packages/debugger/src/locator/index.ts
function makeHoverElementListener(eli, onHover) {
  let last = null;
  makeEventListener(window, "mouseover", (e) => {
    let el = eli.getElementAt(e);
    if (el !== last) {
      onHover(last = el);
    }
  });
  makeEventListener(document, "mouseleave", () => {
    if (null !== last) {
      onHover(last = null);
    }
  });
}
function createLocator(props) {
  const [enabledByPressingSignal, setEnabledByPressingSignal] = createSignal(() => false);
  props.setLocatorEnabledSignal(createMemo(() => enabledByPressingSignal()()));
  const [hoverTarget, setHoverTarget] = createSignal(null);
  const [devtoolsTarget, setDevtoolsTarget] = createSignal(null);
  const [highlightedComponents, setHighlightedComponents] = createSignal([]);
  function getLocatorComponentFromElement(el) {
    let comp = findComponent(props.component_registry, el);
    return comp && {
      location: props.component_registry.eli.getLocation(el),
      element: el,
      id: comp.id,
      name: comp.name
    };
  }
  const target = createMemo(() => {
    let hover = hoverTarget();
    return hover != null ? {
      type: "hover",
      element: hover
    } : devtoolsTarget();
  }, void 0, {
    equals: (a, b) => {
      if (a === b) return true;
      if (a == null && b == null) return true;
      if (a == null || b == null) return false;
      if (a.type !== b.type) return false;
      switch (a.type) {
        case "hover":
          return a.element === b.element;
        case "node":
          return a.id === b.id;
        case "element":
          return a.id === b.id;
      }
    }
  });
  createEffect(defer(target, scheduleIdle((target2) => {
    let locator_components = [];
    if (target2 != null) {
      switch (target2.type) {
        case "hover": {
          unwrap_append(locator_components, getLocatorComponentFromElement(target2.element));
          break;
        }
        case "element": {
          let element = getObjectById(target2.id, "ELEMENT" /* Element */);
          if (element != null) {
            unwrap_append(locator_components, getLocatorComponentFromElement(element));
          }
          break;
        }
        case "node": {
          let comp = getComponent(props.component_registry, target2.id);
          if (comp != null) {
            for (let el of comp.elements) {
              locator_components.push({
                element: el,
                id: comp.id,
                name: comp.name
              });
            }
          }
        }
      }
    }
    setHighlightedComponents(locator_components);
  })));
  createElementsOverlay(highlightedComponents, props.component_registry.eli);
  createEffect((prev) => {
    const target2 = hoverTarget();
    const comp = target2 && findComponent(props.component_registry, target2);
    if (prev) {
      props.emit(msg("HoveredComponent", { nodeId: prev, state: false }));
    }
    if (comp) {
      const { id } = comp;
      props.emit(msg("HoveredComponent", { nodeId: id, state: true }));
      return id;
    }
  });
  let target_ide;
  createEffect(() => {
    if (!props.locatorEnabled()) return;
    makeHoverElementListener(props.component_registry.eli, (el) => setHoverTarget(() => el));
    onCleanup(() => setHoverTarget(null));
    makeEventListener(window, "click", (e) => {
      let el = props.component_registry.eli.getElementAt(e);
      if (el == null) {
        return;
      }
      let comp = getLocatorComponentFromElement(el);
      if (comp == null) {
        return;
      }
      let source_code_data = comp.location ? getSourceCodeData(comp.location) : null;
      props.onComponentClick(comp.id, () => {
        if (target_ide == null || source_code_data == null) return;
        e.preventDefault();
        e.stopPropagation();
        openSourceCode(target_ide, source_code_data);
      });
    }, true);
  });
  let locatorUsed = false;
  const owner = getOwner();
  function useLocator(options) {
    runWithOwner(owner, () => {
      if (locatorUsed) return warn("useLocator can be called only once.");
      locatorUsed = true;
      if (options.targetIDE) target_ide = options.targetIDE;
      if (options.key !== false) {
        const isHoldingKey = createKeyHold(options.key ?? "Alt", { preventDefault: true });
        setEnabledByPressingSignal(() => isHoldingKey);
      }
    });
  }
  let locator_options = setup_default.get_locator_options();
  if (locator_options) {
    useLocator(locator_options);
  }
  return {
    useLocator,
    setDevtoolsHighlightTarget(target2) {
      setDevtoolsTarget(target2);
    },
    openElementSourceCode(location) {
      if (!target_ide) return warn("Please set `targetIDE` it in useLocator options.");
      const projectPath = getProjectPath();
      if (!projectPath) return warn("projectPath is not set.");
      openSourceCode(target_ide, {
        ...location,
        projectPath
      });
    }
  };
}

// packages/debugger/src/inspector/serialize.ts
var Deep;
var List;
var Seen;
var InStore;
var HandleStore;
var IgnoreNextSeen;
var encodeNonObject = (value) => {
  switch (typeof value) {
    case "number":
      if (value === Infinity) return ["number" /* Number */, INFINITY];
      if (value === -Infinity) return ["number" /* Number */, NEGATIVE_INFINITY];
      if (isNaN(value)) return ["number" /* Number */, NAN];
      return ["number" /* Number */, value];
    case "boolean":
      return ["boolean" /* Boolean */, value];
    case "string":
      return ["string" /* String */, value];
    case "symbol":
      return ["symbol" /* Symbol */, value.description || ""];
    case "function":
      return ["function" /* Function */, value.name];
    case "object":
      return ["null" /* Null */, null];
    case "bigint":
    case "undefined":
      return ["null" /* Null */, UNDEFINED];
  }
};
function encode(value, eli) {
  const ignoreNextStore = IgnoreNextSeen;
  if (ignoreNextStore) IgnoreNextSeen = false;
  else {
    const seen = Seen.get(value);
    if (seen !== void 0) return seen;
  }
  if (!value || typeof value !== "object") {
    const index2 = List.push(encodeNonObject(value)) - 1;
    Seen.set(value, index2);
    return index2;
  }
  const encoded = [];
  const index = List.push(encoded) - 1;
  ignoreNextStore || Seen.set(value, index);
  if (eli.isElement(value)) {
    ;
    encoded[0] = "element" /* Element */;
    let id = getSdtId(value, "ELEMENT" /* Element */);
    let name = eli.getName(value);
    encoded[1] = `${id}:${name}`;
  } else if (!ignoreNextStore && isStoreNode(value)) {
    const node = setup_default.store.unwrap(value);
    if (node !== value) Seen.set(node, index);
    const id = getSdtId(node, "STORE_NODE" /* StoreNode */);
    !InStore && HandleStore && HandleStore(node, id);
    const wasInStore = InStore;
    InStore = IgnoreNextSeen = true;
    encoded[0] = "store" /* Store */;
    encoded[1] = `${id}:${encode(node, eli)}`;
    InStore = wasInStore;
  } else if (Array.isArray(value)) {
    ;
    encoded[0] = "array" /* Array */;
    if (Deep) {
      let data = Array(value.length);
      for (let i = 0; i < value.length; i++) {
        data[i] = encode(value[i], eli);
      }
      ;
      encoded[1] = data;
    } else {
      ;
      encoded[1] = value.length;
    }
  } else {
    const name = Object.prototype.toString.call(value).slice(8, -1);
    if (name === "Object") {
      ;
      encoded[0] = "object" /* Object */;
      if (Deep) {
        const data = encoded[1] = {};
        for (const [key, descriptor] of Object.entries(
          Object.getOwnPropertyDescriptors(value)
        )) {
          data[key] = descriptor.get ? -1 : encode(descriptor.value, eli);
        }
      } else {
        ;
        encoded[1] = Object.keys(value).length;
      }
    } else {
      ;
      encoded[0] = "instance" /* Instance */;
      encoded[1] = name;
    }
  }
  return index;
}
function encodeValue(value, deep, eli, handleStore, inStore = false) {
  Deep = deep;
  List = [];
  Seen = /* @__PURE__ */ new Map();
  InStore = inStore;
  HandleStore = handleStore;
  encode(value, eli);
  const result = List;
  Deep = List = Seen = HandleStore = InStore = void 0;
  return result;
}

// packages/debugger/src/inspector/inspector.ts
var $INSPECTOR = Symbol("inspector");
var $NOT_SET = Symbol("not-set");
function value_data_get_value(data) {
  switch (data.kind) {
    case 0 /* Observed_Getter */:
      return data.data.v;
    case 1 /* Value */:
      return data.value;
    case 2 /* Value_Obj */:
      return data.obj.value;
  }
}
function value_node_make(data) {
  return {
    tracked_stores: [],
    selected: false,
    data
  };
}
function value_node_make_obj(obj) {
  return value_node_make({ kind: 2 /* Value_Obj */, obj });
}
function value_node_make_value(value) {
  return value_node_make({ kind: 1 /* Value */, value });
}
function value_node_make_observed_getter(data) {
  return value_node_make({ kind: 0 /* Observed_Getter */, data });
}
function value_node_add_store_observer(node, unsub) {
  node.tracked_stores.push(unsub);
}
function value_node_unsubscribe(node) {
  for (let unsub of node.tracked_stores) unsub();
  node.tracked_stores = [];
}
function value_node_reset(node) {
  value_node_unsubscribe(node);
  node.selected = false;
}
function value_node_is_selected(node) {
  return node.selected;
}
function value_node_set_selected(node, selected) {
  node.selected = selected;
  if (!selected) value_node_unsubscribe(node);
}
function value_node_map_reset(map) {
  for (let signal of map.values()) value_node_reset(signal);
}
function observed_props_make(props) {
  return {
    props,
    on_prop_state_change: void 0,
    on_value_update: void 0,
    observed_getters: {}
  };
}
function observed_props_observe_prop(observed, key, id, get) {
  if (observed.observed_getters[key]) {
    return observed.observed_getters[key];
  }
  let o = observed.observed_getters[key] = { v: $NOT_SET, n: 0 };
  Object.defineProperty(observed.props, key, {
    get() {
      let value = get();
      let listener = setup_default.solid.getListener();
      if (listener != null) {
        onOwnerCleanup(listener, () => {
          if (--o.n === 0) {
            observed.on_prop_state_change?.(key, "stale" /* Stale */);
          }
        });
      }
      if (++o.n === 1) {
        observed.on_prop_state_change?.(key, "live" /* Live */);
      }
      if (value !== o.v) {
        observed.on_value_update?.(id);
      }
      return o.v = value;
    },
    enumerable: true
  });
  return o;
}
function compare_proxy_prop_keys(old_keys, new_keys) {
  let added = new Set(new_keys);
  let removed = [];
  let changed = false;
  for (let key of old_keys) {
    if (added.has(key)) added.delete(key);
    else {
      changed = true;
      removed.push(key);
    }
  }
  if (!changed && !added.size) return null;
  return { added: Array.from(added), removed };
}
function clear_owner_observers(owner, observed_props_map) {
  if (isSolidComputation(owner)) {
    removeValueUpdateObserver(owner, $INSPECTOR);
    if (isSolidComponent(owner)) {
      let observed = observed_props_map.get(owner.props);
      if (observed) {
        observed.on_prop_state_change = void 0;
        observed.on_value_update = void 0;
      }
    }
  }
  if (owner.sourceMap) for (let node of Object.values(owner.sourceMap)) {
    removeValueUpdateObserver(node, $INSPECTOR);
  }
  if (owner.owned) for (let node of owner.owned) {
    removeValueUpdateObserver(node, $INSPECTOR);
  }
}
function map_source_value(node_raw, handler, ctx) {
  let node = getNode(node_raw);
  let { value } = node_raw;
  let id;
  switch (node.kind) {
    case "MEMO" /* Memo */:
      id = getSdtId(node.data, "OWNER" /* Owner */);
      break;
    case "SIGNAL" /* Signal */:
      id = getSdtId(node.data, "SIGNAL" /* Signal */);
      break;
    case "STORE" /* Store */:
      id = getSdtId(node.data, "STORE" /* Store */);
      break;
    case "CUSTOM_VALUE" /* CustomValue */:
      id = getSdtId(node.data, "CUSTOM_VALUE" /* CustomValue */);
      break;
    default:
      return null;
  }
  ctx.value_map.set(`${"signal" /* Signal */}:${id}`, value_node_make_obj(node_raw));
  if (node.kind === "MEMO" /* Memo */ || node.kind === "SIGNAL" /* Signal */) {
    observeValueUpdate(node.data, (v) => handler(id, v), $INSPECTOR);
  }
  return {
    type: node.kind,
    name: getNodeName(node.data),
    id,
    value: encodeValue(value, false, ctx.config.eli)
  };
}
function pre_observe_component_props(component, props_map) {
  let props = component.props;
  if (is_solid_proxy(props)) return;
  let observed = props_map.get(props);
  if (!observed) props_map.set(props, observed = observed_props_make(props));
  for (let [key, desc] of Object.entries(Object.getOwnPropertyDescriptors(props))) {
    if (desc.get != null) {
      observed_props_observe_prop(observed, key, `prop:${key}`, desc.get);
    }
  }
}
function map_props(props, ctx) {
  let is_proxy = is_solid_proxy(props);
  let check_proxy_props;
  let record = {};
  if (is_proxy) {
    let keys2 = Object.keys(props);
    for (let key of keys2) record[key] = { getter: "stale" /* Stale */, value: null };
    check_proxy_props = () => compare_proxy_prop_keys(keys2, keys2 = Object.keys(props));
  } else {
    let observed = ctx.config.props_map.get(props);
    if (!observed) ctx.config.props_map.set(props, observed = observed_props_make(props));
    observed.on_prop_state_change = ctx.config.on_prop_state_change;
    observed.on_value_update = ctx.config.on_value_update;
    for (let [key, desc] of Object.entries(Object.getOwnPropertyDescriptors(props))) {
      let id = `prop:${key}`;
      if (desc.get != null) {
        let prop_data = observed_props_observe_prop(observed, key, id, desc.get);
        ctx.value_map.set(id, value_node_make_observed_getter(prop_data));
        record[key] = {
          getter: prop_data.n === 0 ? "stale" /* Stale */ : "live" /* Live */,
          value: prop_data.v !== $NOT_SET ? encodeValue(prop_data.v, false, ctx.config.eli) : null
        };
      } else {
        record[key] = {
          getter: false,
          value: encodeValue(desc.value, false, ctx.config.eli)
        };
        if (Array.isArray(desc.value) || misc_exports.is_plain_object(desc.value)) {
          ctx.value_map.set(id, value_node_make_value(desc.value));
        }
      }
    }
  }
  return { props: { proxy: is_proxy, record }, check_proxy_props };
}
function collect_owner_details(owner, config) {
  let ctx = {
    value_map: /* @__PURE__ */ new Map(),
    config
  };
  let id = getSdtId(owner, "OWNER" /* Owner */);
  let type = markOwnerType(owner);
  let owned = owner.owned;
  let source_map = owner.sourceMap;
  let value_data = { kind: 2 /* Value_Obj */, obj: owner };
  let details = { id, name: getNodeName(owner), type, signals: [] };
  if (type === "CONTEXT" /* Context */) {
    source_map = void 0;
    owned = null;
    let symbols = Object.getOwnPropertySymbols(owner.context);
    let context_value = owner.context[symbols[symbols.length - 1]];
    value_data = { kind: 1 /* Value */, value: context_value };
  }
  let check_proxy_props;
  if (isSolidComputation(owner)) {
    if (isSolidComponent(owner)) {
      let refresh = getComponentRefreshNode(owner);
      if (refresh) {
        source_map = refresh.sourceMap;
        owned = refresh.owned;
        value_data = { kind: 2 /* Value_Obj */, obj: refresh };
        details.hmr = true;
      }
      ;
      ({ check_proxy_props, props: details.props } = map_props(owner.props, ctx));
      let location;
      if ((location = owner.sdtLocation) && typeof location === "string" && (location = parseLocationString(location)) || (location = owner.component.location) && typeof location === "string" && (location = parseLocationString(location))) {
        details.location = location;
      }
    } else {
      observeValueUpdate(owner, () => ctx.config.on_value_update("value" /* Value */), $INSPECTOR);
    }
    details.value = encodeValue(value_data_get_value(value_data), false, ctx.config.eli);
  }
  let on_signal_update = (signal_id) => ctx.config.on_value_update(`${"signal" /* Signal */}:${signal_id}`);
  if (source_map) for (let signal of source_map) {
    let mapped = map_source_value(signal, on_signal_update, ctx);
    if (mapped) details.signals.push(mapped);
  }
  if (owned) for (let node of owned) {
    let mapped = map_source_value(node, on_signal_update, ctx);
    if (mapped) details.signals.push(mapped);
  }
  if (owner === UNOWNED_ROOT) {
    for (let signal_ref of setup_default.unowned.signals) {
      let signal = signal_ref.deref();
      if (signal == null) continue;
      let mapped = map_source_value(signal, on_signal_update, ctx);
      if (mapped == null) continue;
      details.signals.push(mapped);
    }
  }
  ctx.value_map.set("value" /* Value */, value_node_make(value_data));
  return {
    details,
    value_map: ctx.value_map,
    check_proxy_props
  };
}

// packages/debugger/src/inspector/store.ts
var Nodes = /* @__PURE__ */ new WeakMap();
var OnNodeUpdate2 = null;
function setOnStoreNodeUpdate(fn) {
  OnNodeUpdate2 = fn;
}
setup_default.store.hooks.onStoreNodeUpdate = (node, property, value, prev) => {
  if (!OnNodeUpdate2 || !Nodes.has(node) || typeof property === "symbol") return;
  property = property.toString();
  const storeProperty = `${getSdtId(
    node,
    "STORE_NODE" /* StoreNode */
  )}:${property}`;
  if (property === "length" && typeof value === "number" && Array.isArray(node)) {
    return OnNodeUpdate2(storeProperty, value);
  }
  setup_default.store.isWrappable(prev) && untrackStore(prev, storeProperty);
  if (value === void 0) {
    OnNodeUpdate2(storeProperty, void 0);
  } else {
    OnNodeUpdate2(storeProperty, { value });
    setup_default.store.isWrappable(value) && trackStore(value, storeProperty);
  }
};
function observeStoreNode(rootNode) {
  rootNode = setup_default.store.unwrap(rootNode);
  const symbol = Symbol("inspect-store");
  trackStore(rootNode, symbol);
  return () => untrackStore(rootNode, symbol);
}
function trackStore(node, parent) {
  const data = Nodes.get(node);
  if (data) data.add(parent);
  else {
    Nodes.set(node, /* @__PURE__ */ new Set([parent]));
    const id = getSdtId(node, "STORE_NODE" /* StoreNode */);
    forEachStoreProp(node, (key, child) => trackStore(child, `${id}:${key}`));
  }
}
function untrackStore(node, parent) {
  const data = Nodes.get(node);
  if (data && data.delete(parent)) {
    data.size === 0 && Nodes.delete(node);
    const id = getSdtId(node, "STORE_NODE" /* StoreNode */);
    forEachStoreProp(node, (key, child) => untrackStore(child, `${id}:${key}`));
  }
}
function forEachStoreProp(node, fn) {
  if (Array.isArray(node)) {
    for (let i = 0; i < node.length; i++) {
      const child = node[i];
      setup_default.store.isWrappable(child) && fn(i.toString(), child);
    }
  } else {
    for (const key in node) {
      const { value, get } = Object.getOwnPropertyDescriptor(node, key);
      if (!get && setup_default.store.isWrappable(value)) fn(key, value);
    }
  }
}

// packages/debugger/src/inspector/index.ts
function createInspector(props) {
  let lastDetails;
  let inspectedOwner;
  let valueMap = /* @__PURE__ */ new Map();
  const propsMap = /* @__PURE__ */ new WeakMap();
  let checkProxyProps;
  function getValue(id) {
    let node = valueMap.get(id);
    return node ? value_data_get_value(node.data) : void 0;
  }
  window[GLOBAL_GET_VALUE] = getValue;
  const { pushPropState, pushValueUpdate, pushInspectToggle, triggerPropsCheck, clearUpdates } = (() => {
    const valueUpdates = /* @__PURE__ */ new Map();
    let storeUpdates = [];
    let checkProps = false;
    let propStates = {};
    const flush = scheduleIdle(() => {
      const batchedUpdates = [];
      for (const [id, toggleChange] of valueUpdates) {
        const node = valueMap.get(id);
        if (!node) continue;
        const selected = value_node_is_selected(node);
        const encoded = encodeValue(
          value_data_get_value(node.data),
          selected,
          setup_default.eli,
          selected && ((storeNode) => value_node_add_store_observer(node, observeStoreNode(storeNode)))
        );
        batchedUpdates.push([
          toggleChange === null ? "value" : "inspectToggle",
          [id, encoded]
        ]);
      }
      valueUpdates.clear();
      for (const [storeProperty, data] of storeUpdates)
        batchedUpdates.push([
          "store",
          [
            storeProperty,
            typeof data === "object" ? encodeValue(data.value, true, setup_default.eli, void 0, true) : data ?? null
          ]
        ]);
      storeUpdates = [];
      if (checkProps && checkProxyProps) {
        const keys2 = checkProxyProps();
        if (keys2) batchedUpdates.push(["propKeys", keys2]);
        checkProps = false;
      }
      if (Object.keys(propStates).length) {
        batchedUpdates.push(["propState", propStates]);
        propStates = {};
      }
      if (batchedUpdates.length) {
        props.emit(msg("InspectorUpdate", batchedUpdates));
      }
    });
    const flushPropsCheck = throttle(flush, 200);
    setOnStoreNodeUpdate((...payload) => {
      storeUpdates.push(payload);
      flush();
    });
    return {
      pushValueUpdate(id) {
        valueUpdates.set(id, null);
        flush();
      },
      pushInspectToggle(id, selected) {
        const current = valueUpdates.get(id);
        if (current === selected || current === null) return;
        else if (current === !selected) valueUpdates.delete(id);
        else valueUpdates.set(id, selected);
        flush();
      },
      triggerPropsCheck() {
        checkProps = true;
        flushPropsCheck();
      },
      pushPropState(key, state) {
        propStates[key] = state;
        flush();
      },
      // since the updates are emitten on timeout, we need to make sure that
      // switching off the debugger or unselecting the owner will clear the updates
      clearUpdates() {
        valueUpdates.clear();
        storeUpdates = [];
        checkProps = false;
        flush.clear();
        flushPropsCheck.clear();
      }
    };
  })();
  let clearPrevDisposeListener;
  function inspectOwnerId(id) {
    const owner = id && getObjectById(id, "OWNER" /* Owner */);
    if (inspectedOwner) clear_owner_observers(inspectedOwner, propsMap);
    inspectedOwner = owner;
    value_node_map_reset(valueMap);
    clearUpdates();
    if (owner) {
      const result = collect_owner_details(owner, {
        on_value_update: pushValueUpdate,
        on_prop_state_change: pushPropState,
        props_map: propsMap,
        eli: setup_default.eli
      });
      props.emit(msg("InspectedNodeDetails", result.details));
      valueMap = result.value_map;
      lastDetails = result.details;
      checkProxyProps = result.check_proxy_props || null;
    } else {
      lastDetails = void 0;
      checkProxyProps = null;
    }
    clearPrevDisposeListener?.();
    clearPrevDisposeListener = owner ? onOwnerDispose(owner, props.resetInspectedNode) : void 0;
  }
  const inspectedOwnerId = createMemo(
    () => props.enabled() ? props.inspectedState().ownerId : null
  );
  createEffect(() => {
    let id = inspectedOwnerId();
    untrack(() => inspectOwnerId(id));
  });
  function onUnownedRootChange() {
    if (inspectedOwner === UNOWNED_ROOT) {
      inspectOwnerId(inspectedOwnerId());
    }
  }
  setup_default.unowned.onSignalAdded = onUnownedRootChange;
  setup_default.unowned.onSignalRemoved = onUnownedRootChange;
  createEffect(() => {
    if (!props.enabled()) return;
    onCleanup(addSolidUpdateListener(() => checkProxyProps && triggerPropsCheck()));
  });
  return {
    getLastDetails: () => lastDetails,
    toggleValueNode({ id, selected }) {
      const node = valueMap.get(id);
      if (!node) return warn("Could not find value node:", id);
      value_node_set_selected(node, selected);
      pushInspectToggle(id, selected);
    },
    consoleLogValue(value_id) {
      console.log(getValue(value_id));
    },
    preObserveComponent(component) {
      pre_observe_component_props(component, propsMap);
    }
  };
}

// packages/debugger/src/structure/index.ts
function getClosestIncludedOwner(owner, mode) {
  let closest = null;
  let current = owner;
  do {
    if (isDisposed(current)) closest = current.owner;
    current = current.owner;
  } while (current);
  owner = closest ?? owner;
  if (mode === "owners" /* Owners */) return owner;
  let root = null;
  do {
    const type = markOwnerType(owner);
    if (type === "COMPONENT" /* Component */ || type === "CONTEXT" /* Context */) return owner;
    if (type === "ROOT" /* Root */) root = owner;
    owner = owner.owner;
  } while (owner);
  return root;
}
function createStructure(props) {
  let treeWalkerMode = DEFAULT_WALKER_MODE;
  const updateQueue = /* @__PURE__ */ new Set();
  const ownerRoots = /* @__PURE__ */ new Map();
  const removedRoots = /* @__PURE__ */ new Set();
  let shouldUpdateAllRoots = true;
  const onComputationUpdate = (root_id, owner, changed_structure) => {
    queueMicrotask(() => {
      if (!props.enabled()) return;
      if (changed_structure) {
        let owner_to_update = getClosestIncludedOwner(owner, treeWalkerMode) ?? owner;
        updateOwner(owner_to_update, root_id);
      }
      let id = getSdtId(owner, "OWNER" /* Owner */);
      props.onNodeUpdate(id);
    });
  };
  function forceFlushRootUpdateQueue() {
    if (props.enabled()) {
      let partial = !shouldUpdateAllRoots;
      shouldUpdateAllRoots = false;
      let updated = {};
      let owners;
      let getRootId;
      if (partial) {
        owners = updateQueue;
        getRootId = (owner) => ownerRoots.get(owner);
      } else {
        owners = getCurrentRoots();
        getRootId = (owner) => getSdtId(owner, "OWNER" /* Owner */);
      }
      for (let owner of owners) {
        let root_id = getRootId(owner);
        let tree = walkSolidTree(owner, {
          rootId: root_id,
          mode: treeWalkerMode,
          onUpdate: onComputationUpdate,
          eli: props.component_registry.eli,
          registry: props.component_registry
        });
        let map = updated[root_id];
        if (map != null) map[tree.id] = tree;
        else updated[root_id] = { [tree.id]: tree };
      }
      props.onStructureUpdate({ partial, updated, removed: [...removedRoots] });
    }
    updateQueue.clear();
    flushRootUpdateQueue.clear();
    removedRoots.clear();
    ownerRoots.clear();
  }
  const flushRootUpdateQueue = throttle(forceFlushRootUpdateQueue, 250);
  function updateOwner(node, topRootId) {
    updateQueue.add(node);
    ownerRoots.set(node, topRootId);
    flushRootUpdateQueue();
  }
  setOnOwnerNeedsUpdate((node, topRootId) => {
    const closestIncludedOwner = getClosestIncludedOwner(node, treeWalkerMode);
    closestIncludedOwner && updateOwner(closestIncludedOwner, topRootId);
  });
  setOnRootRemoved((rootId) => {
    removedRoots.add(rootId);
    flushRootUpdateQueue();
  });
  function updateAllRoots() {
    shouldUpdateAllRoots = true;
    flushRootUpdateQueue();
  }
  function forceUpdateAllRoots() {
    shouldUpdateAllRoots = true;
    queueMicrotask(forceFlushRootUpdateQueue);
  }
  function setTreeWalkerMode(mode) {
    treeWalkerMode = mode;
    updateAllRoots();
    clearComponentRegistry(props.component_registry);
  }
  return {
    updateAllRoots,
    forceUpdateAllRoots,
    setTreeWalkerMode,
    resetTreeWalkerMode: () => setTreeWalkerMode(DEFAULT_WALKER_MODE),
    getClosestIncludedOwner(owner) {
      return getClosestIncludedOwner(owner, treeWalkerMode);
    },
    onViewChange(view) {
      if (view === "structure" /* Structure */) {
        updateAllRoots();
      }
    }
  };
}

// packages/debugger/src/main/index.ts
function createDebugger() {
  assert(globalThis.SolidDevtools$$, "solid-devtools is not setup");
  const _output_listeners = [];
  function listen(listener) {
    _output_listeners.push(listener);
    return () => mutate_remove(_output_listeners, listener);
  }
  function emitOutput(e) {
    for (let fn of _output_listeners) fn(e);
  }
  const [modules, toggleModules] = createStaticStore({
    debugger: false,
    locator: false,
    dgraph: false,
    locatorKeyPressSignal: () => false
  });
  const debuggerEnabled = createMemo(
    () => modules.debugger || modules.locatorKeyPressSignal()
  );
  const dgraphEnabled = createMemo(
    () => modules.dgraph && debuggerEnabled()
  );
  const locatorEnabled = createMemo(
    () => (modules.locatorKeyPressSignal() || modules.locator) && debuggerEnabled()
  );
  createEffect(defer(debuggerEnabled, (enabled) => {
    emitOutput(msg("DebuggerEnabled", enabled));
  }));
  let currentView = DEFAULT_MAIN_VIEW;
  function toggleModule(data) {
    switch (data.module) {
      case "structure" /* Structure */:
        break;
      case "dgraph" /* Dgraph */:
        toggleModules("dgraph", data.enabled);
        break;
      case "locator" /* Locator */:
        toggleModules("locator", data.enabled);
        break;
    }
  }
  const [inspectedState, setInspectedState] = createSignal(
    INSPECTED_STATE_NULL,
    { equals: false }
  );
  createEffect(() => {
    emitOutput(msg("InspectedState", inspectedState()));
  });
  function getTreeWalkerOwnerId(ownerId) {
    const owner = ownerId && getObjectById(ownerId, "OWNER" /* Owner */);
    const treeWalkerOwner = owner && structure.getClosestIncludedOwner(owner);
    return treeWalkerOwner ? getSdtId(treeWalkerOwner, "OWNER" /* Owner */) : null;
  }
  function setInspectedNode(data) {
    if (data == null) {
      setInspectedState(INSPECTED_STATE_NULL);
    } else {
      let ownerId = data.ownerId && getObjectById(data.ownerId, "OWNER" /* Owner */) && data.ownerId;
      let signalId = data.signalId && getObjectById(data.signalId, "SIGNAL" /* Signal */) && data.signalId;
      let treeWalkerOwnerId = getTreeWalkerOwnerId(ownerId);
      setInspectedState({ ownerId, signalId, treeWalkerOwnerId });
    }
  }
  createComputed(defer(debuggerEnabled, (enabled) => {
    if (!enabled) setInspectedState(INSPECTED_STATE_NULL);
  }));
  let node_updates_ids = [];
  let node_updates_timeout = null;
  function pushNodeUpdate(id) {
    node_updates_ids.push(id);
    if (node_updates_timeout == null) {
      node_updates_timeout = setTimeout(() => {
        emitOutput(msg("NodeUpdates", node_updates_ids));
        node_updates_ids = [];
        node_updates_timeout = null;
      });
    }
  }
  let component_registry = makeComponentRegistry(setup_default.eli);
  const structure = createStructure({
    onStructureUpdate(updates) {
      emitOutput(msg("StructureUpdates", updates));
      setInspectedState((p) => ({
        ...p,
        treeWalkerOwnerId: getTreeWalkerOwnerId(p.treeWalkerOwnerId)
      }));
    },
    onNodeUpdate: pushNodeUpdate,
    enabled: debuggerEnabled,
    component_registry
  });
  const inspector = createInspector({
    enabled: debuggerEnabled,
    inspectedState,
    resetInspectedNode: () => setInspectedState(INSPECTED_STATE_NULL),
    emit: emitOutput
  });
  const dgraph = createDependencyGraph({
    enabled: dgraphEnabled,
    onNodeUpdate: pushNodeUpdate,
    inspectedState,
    emit: emitOutput
  });
  const locator = createLocator({
    locatorEnabled,
    setLocatorEnabledSignal(signal) {
      toggleModules("locatorKeyPressSignal", () => signal);
    },
    onComponentClick(componentId, next) {
      if (modules.debugger) {
        emitOutput(msg("InspectedComponent", componentId));
      } else {
        next();
      }
    },
    emit: emitOutput,
    component_registry
  });
  function openInspectedNodeLocation() {
    const details = inspector.getLastDetails();
    details?.location && locator.openElementSourceCode(details.location);
  }
  createEffect(defer(modules.locatorKeyPressSignal, (state) => {
    emitOutput(msg("LocatorModeChange", state));
  }));
  attachDebugger(UNOWNED_ROOT);
  for (const e of setup_default.get_created_owners()) {
    handleCreatedOwner(e);
  }
  setup_default.solid.hooks.afterCreateOwner = handleCreatedOwner;
  function handleCreatedOwner(owner) {
    if (isSolidRoot(owner)) {
      attachDebugger(owner);
    } else if (isSolidComponent(owner)) {
      inspector.preObserveComponent(owner);
    }
  }
  function emitInput(e) {
    switch (e.kind) {
      case "ResetState": {
        batch(() => {
          setInspectedState(INSPECTED_STATE_NULL);
          currentView = DEFAULT_MAIN_VIEW;
          structure.resetTreeWalkerMode();
          locator.setDevtoolsHighlightTarget(null);
        });
        break;
      }
      case "HighlightElementChange":
        locator.setDevtoolsHighlightTarget(e.data);
        break;
      case "InspectNode":
        setInspectedNode(e.data);
        break;
      case "InspectValue":
        inspector.toggleValueNode(e.data);
        break;
      case "ConsoleInspectValue":
        inspector.consoleLogValue(e.data);
        break;
      case "OpenLocation":
        openInspectedNodeLocation();
        break;
      case "TreeViewModeChange":
        structure.setTreeWalkerMode(e.data);
        break;
      case "ViewChange":
        currentView = e.data;
        structure.onViewChange(currentView);
        dgraph.onViewChange(currentView);
        break;
      case "ToggleModule":
        toggleModule(e.data);
        break;
    }
  }
  return {
    versions: setup_default.versions,
    enabled: debuggerEnabled,
    listen,
    emit: emitInput,
    setLocatorOptions: locator.useLocator,
    toggleEnabled(enabled) {
      toggleModules("debugger", enabled);
    }
  };
}
var _debugger_instance;
function useDebugger() {
  _debugger_instance ??= createDebugger();
  return _debugger_instance;
}
export {
  addSolidUpdateListener,
  attachDebugger,
  getNodeName,
  getNodeType,
  getOwnerType,
  interceptComputationRerun,
  isSolidComputation,
  isSolidMemo,
  isSolidOwner,
  isSolidRoot,
  isSolidSignal,
  isSolidStore,
  lookupOwner,
  makeValueUpdateListener,
  observeValueUpdate,
  onOwnerCleanup,
  onParentCleanup,
  removeValueUpdateObserver,
  useDebugger
};
